/*
 Copyright 2019 Adobe. All rights reserved.
 This file is licensed to you under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License. You may obtain a copy
 of the License at http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under
 the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 OF ANY KIND, either express or implied. See the License for the specific language
 governing permissions and limitations under the License.
 */

package com.adobe.skyline.migration.transformer.processingprofile;

import com.adobe.skyline.migration.MigrationConstants;
import com.adobe.skyline.migration.model.ProcessingProfile;
import com.adobe.skyline.migration.model.RenditionConfig;
import com.adobe.skyline.migration.model.workflow.Workflow;
import com.adobe.skyline.migration.model.workflow.WorkflowLauncher;
import com.adobe.skyline.migration.util.StringUtil;

import java.util.*;

/**
 * The MimetypeMerger manages merging together the mimetype includes and excludes as specified by any number of workflow
 * launchers for a given workflow as well as any number of duplicate renditions generated by that workflow into a single
 * set of includes and excludes to be applied to a single output rendition.
 */
public class MimeTypeMerger {

    Set<String> launcherIncludes;
    Set<String> launcherExcludes;

    public MimeTypeMerger(Workflow workflow) {
        launcherIncludes = new HashSet<>();
        launcherExcludes = new HashSet<>();

        extractMimetypesFromLaunchers(workflow);
    }

    public void mergeRenditionMimetypes(ProcessingProfile profile) {
        for (RenditionConfig rendition : profile.getRenditions()) {
            mergeRenditionAndLauncherMimeTypes(rendition);
        }

        // If a workflow step's included mimetypes contradicts the launcher's excluded mimetypes, no assets should
        // be processed through this rendition.  Thus, remove it entirely.
        profile.getRenditions().removeIf(r -> r.getIncludeMimeTypes().size() == 0);
    }

    /**
     * Extract mimetypes from the workflow launchers.  This is tricky business as at first glance, workflow launcher configurations
     * may seem to be contradictory.
     *
     * For example, one workflow launcher's condition may state jcr:content/jcr:mimeType!=video/.*
     * while a second launcher's may state jcr:content/jcr:mimeType==video/.*.  It may seem that this combination of launcher
     * configurations would prevent this workflow from ever running, while in fact, this workflow will run against all uploaded
     * assets.  The trick is that the first launcher is not actually an _exclusion_ for video/.* but rather is an _inclusion_
     * for everything else.  In effect, the first launcher will fire for anything other than videos, the second will fill
     * in the gap by firing for videos.
     *
     * In our case, we will need to compare between the includes and excludes and across the various launchers to create
     * a combined set that results in the same behavior even though it is expressed differently.  We do this by making
     * includes always win when we run into contradictory definitions.
     */
    private void extractMimetypesFromLaunchers(Workflow workflow) {
        for (WorkflowLauncher launcher : workflow.getLaunchers()) {
            if (launcher.getConditions() != null && launcher.getConditions().size() > 0) {
                for (String condition:launcher.getConditions()) {
                    String mimeType = condition.substring(condition.lastIndexOf("=") + 1);

                    if (condition.contains("mimeType=") || condition.contains("mimeType==")) {
                        includeMimeType(mimeType);
                    } else if (condition.contains("mimeType!=")) {
                        excludeMimeType(mimeType);
                        // If a launcher specifies an exclusion only, it infers inclusion of the default
                        if (!launcherExcludes.contains(MigrationConstants.DEFAULT_MIMETYPE)) {
                            launcherIncludes.add(MigrationConstants.DEFAULT_MIMETYPE);
                        }
                    } else {
                        // In a case where a launcher specifies a condition other than mimeType, ignore it
                        if (!launcherExcludes.contains(MigrationConstants.DEFAULT_MIMETYPE)) {
                            launcherIncludes.add(MigrationConstants.DEFAULT_MIMETYPE);
                        }
                    }
                }
            } else {
                // If a launcher doesn't specify any condition, it infers inclusion of the default
                launcherIncludes.add(MigrationConstants.DEFAULT_MIMETYPE);
            }

        }
    }

    private void includeMimeType(String mimeType) {
        List<String> mimeTypes = normalizeMimeTypes(mimeType);

        for (String type : mimeTypes) {
            launcherIncludes.add(type);

            if (launcherExcludes.contains(type)) {
                launcherExcludes.remove(type);
            }
        }
    }

    private void excludeMimeType(String mimeType) {
        List<String> mimeTypes = normalizeMimeTypes(mimeType);

        for (String type : mimeTypes) {
            if (!launcherIncludes.contains(type)) {
                launcherExcludes.add(type);
            }
        }
    }

    /**
     * The input is a single string but the output is a List.  This is due to the fact that mimetypes are sometimes
     * specified as a single value and are sometimes specified as an array, depending on the implementation that they
     * were taken from.
     */
    private List<String> normalizeMimeTypes(String mimeType) {
        List<String> rawTypes;

        if (mimeType.startsWith("[")) {
            rawTypes = StringUtil.getListFromString(mimeType);
        } else {
            rawTypes = Arrays.asList(mimeType);
        }

        List<String> normalizedTypes = new ArrayList<>();

        for (String entry : rawTypes) {
            normalizedTypes.add(
                    entry.replace("(", "").replace(")", ""). // Remove parentheses
                            replace("/*", "/.*") // Insert a dot when missing
            );
        }

        return normalizedTypes;
    }

    /**
     * When considering the interaction between rendition-specified mimetypes and launcher-specified mimetypes, it is important
     * to understand that the launcher configuration is applied first - any asset that does not meet the launcher configuration
     * will never make it to the rendition configuration.  Therefore, when calculating the union of these rules, we must
     * apply the rendition specification as subtractive, meaning that we take the set of renditions specified by the launcher
     * and further restrict it.
     *
     * As a result, the rendition's excluded mimetypes will be added to the launcher's.  The rendition's included mimetypes
     * should replace the included mimetypes from the launcher, but only if they are more restrictive.  Determining whether
     * a mimetype is more restrictive would require building a model of each possible mimetype mapping and their relationships,
     * for example, image/jpeg is a subset of image/*.  As this would require significant development effort, we are taking
     * a more basic approach for the initial implementation of this tool and are replacing the includes from the launcher
     * with the includes from the rendition, if specified, blindly.
     */
    private void mergeRenditionAndLauncherMimeTypes(RenditionConfig rendition) {
        //Clone the values from the launcher
        Set<String> mergedIncludes = new HashSet<>(launcherIncludes);
        Set<String> mergedExcludes = new HashSet<>(launcherExcludes);


        if (rendition.getIncludeMimeTypes().size() > 0) {
            mergedIncludes = new HashSet<>(); //Reset the mergedIncludes as the rendition includes should _replace_ those from the launcher

            for (String mimeType : rendition.getIncludeMimeTypes()) {
                List<String> mimeTypes = normalizeMimeTypes(mimeType);

                for (String type : mimeTypes) {
                    if (!mergedExcludes.contains(type)) {
                        mergedIncludes.add(type);
                    }
                }
            }
        }

        //Merge the rendition excludes
        for (String mimeType : rendition.getExcludeMimeTypes()) {
            List<String> mimeTypes = normalizeMimeTypes(mimeType);

            for (String type : mimeTypes) {
                if (mergedIncludes.contains(type)) {
                    mergedIncludes.remove(type);
                }

                mergedExcludes.add(type);
            }
        }

        rendition.setIncludeMimeTypes(mergedIncludes);
        rendition.setExcludeMimeTypes(mergedExcludes);
    }
}